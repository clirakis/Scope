<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (X11; I; Linux 2.0.35 i686) [Netscape]">
</HEAD>
<BODY>

<PRE>#include &lt;errno.h>
#include &lt;stdio.h>

#ifdef LINUX&nbsp;
#&nbsp; include &lt;sys/types.h>
#&nbsp; include &lt;sys/time.h>
#&nbsp; include &lt;sys/socket.h>
#&nbsp; include &lt;linux/in.h>
#&nbsp; include &lt;netdb.h>
#&nbsp; include "<A HREF="dummyvmeproc.h">dummyvmeproc.h</A>"
#endif

#ifdef LYNX&nbsp;
#&nbsp; include &lt;sys/types.h>
#&nbsp; include &lt;time.h>
#&nbsp; include &lt;socket.h>
#&nbsp; include &lt;bsd/in.h>
#&nbsp; include &lt;netdb.h>
#&nbsp; include "<A HREF="e7.h">e7.h</A>"
#endif

#ifdef OSK
#&nbsp; include &lt;types.h>
#&nbsp; include &lt;socket.h>
#&nbsp; include &lt;in.h>&nbsp;
#&nbsp; include &lt;netdb.h>
#&nbsp; include "<A HREF="http://home.cern.ch/~misko/trigger/fic.h">fic.h</A>"
#&nbsp; define perror printf("Error in "); printf
#endif

#define MAX_MESS_LEN 1024

/*****************************************************************************/
void ShowBuffer(buffer, nchar)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned char * buffer;
&nbsp;&nbsp;&nbsp;&nbsp; int nchar;
{
&nbsp; int i;
&nbsp; for (i=0; i&lt;nchar; i++) printf("(%02x)",buffer[i]);
&nbsp; if (i > 0) printf("\n");
}
/*****************************************************************************/
void main(argc,argv)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; int argc;
&nbsp;&nbsp;&nbsp;&nbsp; char* argv[];
{
&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd, tmp_fd;
&nbsp; struct sockaddr_in ser_sockad;
&nbsp; struct sockaddr_in cli_sockad;
&nbsp; unsigned short&nbsp; ser_port = 7777;
&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len;
&nbsp; unsigned char&nbsp;&nbsp; command[MAX_MESS_LEN];
&nbsp; unsigned char&nbsp;&nbsp; respons[MAX_MESS_LEN];
&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comlen;
&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;
&nbsp; struct hostent *pHE = NULL;
&nbsp; struct hostent&nbsp; sHE;
&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vme_addr;
&nbsp; long int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vme_len;
&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; verbose=0;

&nbsp; if (argc == 2) {
&nbsp;&nbsp;&nbsp; if (strcmp(argv[1],"-v") == 0) verbose = 1;
&nbsp; }

&nbsp; if ((fd=socket(AF_INET,SOCK_STREAM,0)) &lt; 0) {
&nbsp;&nbsp;&nbsp; perror("server socket");
&nbsp;&nbsp;&nbsp; close(fd);
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; }

&nbsp; ser_sockad.sin_family&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = AF_INET;
&nbsp; ser_sockad.sin_port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = htons(ser_port);
&nbsp; ser_sockad.sin_addr.s_addr = INADDR_ANY;

&nbsp; if (bind(fd,(struct sockaddr *)&amp;ser_sockad,sizeof(struct sockaddr_in)) &lt; 0) {
&nbsp;&nbsp;&nbsp; perror("assigning name to the socket");
&nbsp;&nbsp;&nbsp; close(fd);
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; }

&nbsp; if (listen(fd,1) &lt; 0) {
&nbsp;&nbsp;&nbsp; perror("server listen");
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; }

&nbsp; if (verbose) printf("server: waiting for requests on port %d\n",ser_sockad.sin_port);

listening:;
&nbsp; len=sizeof(struct sockaddr_in);
&nbsp; if ((tmp_fd=accept(fd,(struct sockaddr *) &amp;cli_sockad,&amp;len)) &lt; 0) {
&nbsp;&nbsp;&nbsp; perror("server accept");
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; }

#ifndef OSK
&nbsp; switch (fork()) {
&nbsp; case -1:
&nbsp;&nbsp;&nbsp; fprintf(stderr,"Cannot fork\n");
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; case 0:
&nbsp;&nbsp;&nbsp; printf("I am child\n");
&nbsp;&nbsp;&nbsp; break;
&nbsp; default:
&nbsp;&nbsp;&nbsp; printf("I am parent\n");
&nbsp;&nbsp;&nbsp; goto listening;
&nbsp; }
#endif

&nbsp; if ((pHE = gethostbyaddr((char *) &amp;cli_sockad.sin_addr,len,AF_INET))&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != NULL ) {
&nbsp;&nbsp;&nbsp; sHE = *pHE;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; sHE.h_name = "unknown host";
&nbsp; }&nbsp;

&nbsp; if (verbose) printf("server: connection to client on %s opened, id=%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sHE.h_name,tmp_fd);

&nbsp; open_vme_access();
&nbsp;&nbsp;
&nbsp; /*
&nbsp;&nbsp; *&nbsp; loop over clients commands
&nbsp;&nbsp; * ---------------------------
&nbsp;&nbsp; */

&nbsp; while ((comlen=recv(tmp_fd,command,MAX_MESS_LEN,0)) > 0) {
&nbsp;&nbsp;&nbsp; if (verbose) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("command: ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowBuffer(command,comlen);
&nbsp;&nbsp;&nbsp; }

&nbsp; /*
&nbsp;&nbsp; * unpack command:
&nbsp;&nbsp; * 4 bytes root message length
&nbsp;&nbsp; * 4 bytes root message type
&nbsp;&nbsp; * 4 bytes address in VME
&nbsp;&nbsp; * 4 bytes number of bytes to read or write
&nbsp;&nbsp; * rest, if present - bytes to write.
&nbsp;&nbsp; */

&nbsp;&nbsp;&nbsp; if (comlen>=MAX_MESS_LEN) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"triserver: command too long %d\n",comlen);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; if (comlen&lt;16) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr,"triserver: command too short %d\n",comlen);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; memcpy(&amp;vme_addr,command +8,4);
&nbsp;&nbsp;&nbsp; memcpy(&amp;vme_len, command+12,4);

&nbsp;&nbsp;&nbsp; vme_addr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ntohl(vme_addr);
&nbsp;&nbsp;&nbsp; vme_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = ntohl(vme_len);

&nbsp;&nbsp;&nbsp; if (comlen==16) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read vme and write the read bytes on respons */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vme_access("r",vme_addr,(short int *) respons,vme_len);
&nbsp;&nbsp;&nbsp; } else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write vme and write OK on respons */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vme_access("w",vme_addr,(short int *) (command+16),vme_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(respons,"OK");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vme_len=2;
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; /* send respons to client */

&nbsp;&nbsp;&nbsp; i=send(tmp_fd,respons,vme_len,0);
&nbsp;&nbsp;&nbsp; if (verbose) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("respons: ");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowBuffer(respons,vme_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp; }

&nbsp; close_vme_access();
&nbsp; shutdown(tmp_fd,2);
&nbsp; close(tmp_fd);
&nbsp; if (verbose) printf("server: connection to client on %s closed, id=%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sHE.h_name,tmp_fd);

#ifdef OSK&nbsp;
&nbsp; goto listening;
#endif

&nbsp; close(fd);
&nbsp; exit(0);
}
/*****************************************************************************/</PRE>

</BODY>
</HTML>
